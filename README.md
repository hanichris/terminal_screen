![OS support](https://img.shields.io/badge/OS-macOS%20Linux%20-red)

# TERMINAL SCREEN

## Introduction.

Terminal screen is a program that takes as its input a stream of bytes in the following format

```
+--------------+-------------+-------------+-------------+--- ··· ---+----------------+
| Command Byte | Length Byte | Data Byte 0 | Data Byte 1 | ··· | Data Byte n-1 |
+--------------+-------------+-------------+-------------+--- ··· ---+----------------+
```

and draws the output of the operation that this stream of bytes encodes to a screen in the terminal window from which the program was launched. This stream of bytes acts as a means of communication between two active processes, a concept that plays a role in the design of the program.

The data format of the byte stream is an array of bytes categorized into sections that start with a command byte, which specifies the desired operation, a length byte that captures how many arguments the command takes and finally a sequence of data bytes that act as the arguments to the command.

> [!WARNING]
> Terminal Screen is not production ready. Do not use this in production environments.

## Architectural design.

The format presented within the introduction is reminiscent of bytecode generated by interpreted languages like **Python**. As such, terminal screen is broken down into the two following sections:

1. **src**: Defines a virutal machine that will interpret the bytecode it receives and render the output of the commands encoded in the bytecode to the screen.
2. **test**: Defines a tokenizer and parser that reads the input from the REPL and generates the corresponding bytecode.

Because the idealised use case of terminal screen is a computer program communicating with the screen, the two pieces are as presented. The tokeniser and parser abstract a computer program that generates the desired commands and represents them in the bytecode. The virtual
machine takes as its input the bytecode, interprets it and manipulates the screen in accordance to what the bytecode encapsulates.

Given the two executables exist as separate, dependent processes running on the same machine, there is need for interprocess communication (IPC) which is achieved through the use of named pipes. They are simpler to implement and it is left upto the kernel to handle the synchronisation of the communication channel. To aid the kernel in its synchronisation, the bytecode generated by the tokeniser and parser needs to be serialised before being sent through the pipe. On the other end, the bytecode is deserialised before being fed to the virutal machine.

## Execution.

### Requiremets.

1. gcc version 14.2.0
2. make
3. Unix-like OS.
4. C23

> [!NOTE]  
> Terminal Screen was tested on Mac OS. It uses gcc as the compiler of choice. Ensure the environment variable CC on your system points to gcc version 14.2.0 and above otherwise the program will not compile as it uses expressions only available on this version.

### Demo.

Run the following to build terminal screen and generate two executables:

```bash
make
```

If you encounter an error while building the progam, ensure you have a C compiler that supports the features introduced in the C23 standard like **_constexpr_**, **_nullptr_**, **_bool_** without needing to include the **stdbool** header file, etc.

With a successful build, open two instances of your terminal and run the two executables:

```bash
./build/screen
```

```bash
./build/stream
```

In the terminal window in which you executed the **_./build/stream_** executable, a REPL wiil be presented using a chevron, i.e:

```bash
>>>
```

Run the following commands in the REPL, one after the other:

1. Setup a screen with a width of 40 characters, a height of 25 characters, and supporting 8-bit colour.

```bash
>>> screen(40, 25, 2);
```

2. Render the text "HELLO, WORD!!!" starting at point (19, 12), using the colour index 196.

```bash
>>> render(19, 25, 196, "HELLO, WORD!!!");
```

3. Clear the screen.

```bash
>>> clear();
```

These and other commands are supported in the REPL.

## Supported commands.

| Name           | Command                                        | Description                                                   |
| :------------- | :--------------------------------------------- | :------------------------------------------------------------ |
| Setup Screen   | screen(width, height, mode);                   | Defines the dimensions and colour setting of the screen.      |
| Draw Character | draw(x, y, colour, ASCII character);           | Places a character at the specified coordinate of the screen. |
| Draw Line      | line(x0, y0, x1, y1, colour, ASCII character); | Draws a line from one coordinate of the screen to another.    |
| Render Text    | render(x, y, colour, "text to render");        | Renders a string starting from the specified position.        |
| Move cursor    | move(x, y);                                    | Moves the cursor without drawing on the screen.               |
| Draw at cursor | dcur(ASCII character, colour);                 | Draws a character at the cursor location.                     |
| Clear Screen.  | clear();                                       | Clears the screen.                                            |

> [!NOTE]  
> Given that the stream is an array of bytes, the dimensions and coordinates can only be between 0 and 255.

> [!NOTE]
> Only three screen colour settings are supported: 0x00 for **_MONOCHROME_**, 0x01 for **_16 colours_**, and 0x02 for **_256 colours_**.

When using 4-bite colours (0x01):
| Color Name | Color Code |
| :--------- | :-------------------- |
| Black | `30` |
| Red | `31` |
| Green | `32` |
| Yellow | `33` |
| Blue | `34` |
| Magenta | `35` |
| Cyan | `36` |
| White | `37` |
| Bright Black | `90` |
| Bright Red | `91` |
| Bright Green | `92` |
| Bright Yellow | `93` |
| Bright Blue | `94` |
| Bright Magenta | `95` |
| Bright Cyan | `96` |
| Bright White | `97` |

When using 8-bit colours (0x02):
![256 Color table](https://user-images.githubusercontent.com/995050/47952855-ecb12480-df75-11e8-89d4-ac26c50e80b9.png)
